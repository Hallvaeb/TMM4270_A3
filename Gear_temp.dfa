#! NX/KF 4.0

DefClass: Gear_temp (ug_base_part %ug_create_instance);

	# These are default values if not provided by parent (GearBox).
	(number parameter) gear_ratio: 1; 
	(number parameter) given_radius: 123456789*1/2;
	(number parameter) tooth_length: 21.25;
	
# This is actual radius of this gear-instance. Includes the teeth.
	(number parameter) actual_radius: given_radius:*gear_ratio:;
	
	# The gear without the teeth is cylinder
	(number parameter) cylinder_radius: actual_radius: - tooth_length:;
	(number parameter) height: actual_radius:/5;
	
# Number of teeth is integer param so NX complains if the number is not an int. The given user input radius is restricted so it must become an int when multiplied by 0.128, eg. 125, 250, 375, 500 and so on. This is to have appropriate number of teeth to radius ratio.
(integer parameter) number_of_teeth: actual_radius:*0.128; 
	
	# 360 gives error as it (we believe) allows an overlap on the final tooth being placed.
	(number parameter) angle: 359/number_of_teeth:; 

# Make cylinder for the gear
(child) cylinder: {
	class, ug_cylinder;
	diameter, cylinder_radius:*2;
	height, height:;
	Origin, Point(0,0,0);
	Direction, Vector(0,0,1); 
};

# Make hole in cylinder for the gear
(child) hole: {
	class,          ug_cylinder;
	diameter,       cylinder_radius:/15; 
	height,         height:;
	Origin,         Point(0,0,0);
	Direction,      Vector(0,0,1);
	Operation, Subtract;
	Target, {cylinder:};
};

# Unite the first half of the teeth with the cylinder to make up the gear
(list) teeth_list: loop
{
  for $i from 1-number_of_teeth:/4 to number_of_teeth:/4;
  for $x is (cylinder_radius:-0.1*tooth_length:)*cos($i*angle:);
  for $y is (cylinder_radius:-0.1*tooth_length:)*sin($i*angle:);
  for $pt is Point($x,$y,0);
  append {ug_createInstance(
  {
   	 	class, ug_block;
		height, height:;
		width, tooth_length:;
		length, tooth_length:;
			referenceframe, framexy($pt, 
				vector(cos($i*angle:), sin($i*angle:), 0),
				vector(0,1,0)); 
   		Operation, unite;
   		Target, {cylinder:};
  	})}; 
};

# Unite the second half of the teeth with the cylinder to make up the gear. The only change (in addition to i looping over the second half) being we had to make the second vector input in referenceframe negative (see report)
(list) teeth_list_2: loop
{
  for $i from 1+number_of_teeth:/4 to 3*number_of_teeth:/4;
  for $x is (cylinder_radius:-0.1*tooth_length:)*cos($i*angle:);
  for $y is (cylinder_radius:-0.1*tooth_length:)*sin($i*angle:);
  for $pt is Point($x,$y,0);
  append {ug_createInstance(
  {
   	 	class, ug_block;
		height, height:;
		width, tooth_length:;
		length, tooth_length:;
			referenceframe, framexy($pt, 
				vector(cos($i*angle:), sin($i*angle:), 0),
				vector(0,-1,0)); 
# The only change between the loops is the vector above.
   		Operation, unite;
   		Target, {cylinder:};
  	})}; 
};

(list) DemandValue: {teeth_list:, teeth_list_2:};
